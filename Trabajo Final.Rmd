---
title: "Trabajo final de Cálculo Actuarial III"
author: "Bernardo Mondragón Brozon, Anjara Rueda"
date: "May 12, 2018"
output: pdf_document
---

<!-- Configure R Markdown file -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Define the size of the graphs
knitr::opts_chunk$set(fig.width=4.5, fig.height=3, fig.align = "center")
# Create beautiful graphs
#install.packages("ggplot")
library(ggplot2)
# TeX expressions in graphs labels
#install.packages("latex2exp")
library(latex2exp)
# Calculate Kurtosis skew and other functions
#install.packages("moments")
library(moments)
# Para knitear
#install.packages("knitr")
library(knitr)
# Para imprimir tablas
#install.packages("kableExtra")
library(kableExtra)

# Color?
colorImp <- TRUE 
```

\section{1.1 La severidad total}

La severidad total está dada por lo siguiente:
$$ S=x_1+x_2+\cdots+x_N  $$
```{r, parameters, include=FALSE}
lambda_po <- 0.1
denom <- 10000 # Por la parametrizacion de la exponencial
lambda_exp <- 1/denom
```
En donde $\{x_i\}_{i=1\dots N}$ son variables aleatorias independientes e idénticamente distribuidas que indican los montos tal que $x_i$ sigue una distribución exponencial con media $1/\lambda_{exp}=`r denom`$ para toda $i$, y $N$ es la variable aleatoria independiente de las $x_i$'s que indica la frecuencia de los montos tal que sigue una distribución de Poisson con media $\lambda_{Po}=`r lambda_po`$ eventos en un año.

Por el teorema de probabilidad total se tiene que 
$$Pr\{S\leq s|N=n\}=\frac{Pr\{S\leq s,N=n\}}{Pr\{N=n\}}  $$
$$\Rightarrow \quad Pr\{S\leq s,N=n\}=Pr\{N=n\}Pr\{S\leq s|N=n\}.$$
Por lo tanto se tiene que 
$$\begin{aligned}
  F_S(s) &= \sum_{n=0}^{\infty}Pr\{S\leq s,N=n\}  \\
            &= \sum_{n=0}^{\infty}Pr\{N=n\}Pr\{S\leq s|N=n\} \\
            &= \sum_{n=0}^{\infty}Pr\{N=n\}Pr\{\sum_{i=n}^{N}x_i\leq s|N=n\} \\
            &= \sum_{n=0}^{\infty}Pr\{N=n\}F_X^{*n}(s).
\end{aligned}$$

En donde $F_X^{*n}(s)$ es la convolución de las variables aleatorias $\{x_i\}_{i=1\dots N}$, o bien, la función de distribucion de probabilidad acumulada de $\sum_{i=n}^{N}x_i$ con $x_i \sim exp(\lambda_{exp}=1/`r  denom`)$. 
Sean $M_{\sum_{i=n}^{N}x_i}(t)$ y $M_{x_1}(t)$ las funciones generadoras de momentos de las variables aleatorias $\sum_{i=n}^{N}x_i$ y $x_1$ respectivamente, entonces, sin pérdida de generalidad, se tiene que

$$M_{\sum_{i=n}^{N}x_i}(t)=\prod_{i=1}^n M_{x_1}(t)=\prod_{i=1}^n\frac{\lambda_{exp}}{\lambda_{exp}+t}=\left(\frac{\lambda_{exp}}{\lambda_{exp}+t}\right)^n=\left(1-\frac{t}{\lambda_{exp}}\right)^{-n}.$$

Lo cual corresponde a la función generadora de momentos de una variable aleatoria distribuida Gamma con parámetros de $\alpha = n$ y $\beta = \lambda_{exp}$. Además, la distribución de la frecuencia es Poisson con parámetros $\lambda_{Po}=`r lambda_po`$, entonces se sigue que
$$F_S(s)=\sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t $$
```{r plot S CDF, echo=FALSE, warning=FALSE}
# CDF Compound Poisson Distribution 
cdf.comp.pois <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.000001
  
  # Define the region of integration
  B <- c(0, x)
  
  # Calculate the sum
  # prob starts in zero because the severity is a positive random variable
  # First term
  prob <- 0 
  if (B[1] == 0) prob <- exp(-lambda_po)
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * pgamma(B[2], shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.cdf.comp.pois <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=cdf.comp.pois, lambda_po=lambda_po,lambda_exp=lambda_exp)

# Create a plot
p <- ggplot()

# Plot axes to make it look nicer
xAxis <- geom_hline(yintercept = 0, size = .5)
yAxis <-geom_vline(xintercept = 0, size = .5)

# Plot axes labels
cdf.comp.pois.labels <- labs(x = TeX('$s$'), y = TeX('$F_S(s)$'))
# Title
cdf.comp.pois.title <- ggtitle("Función de probabilidad acumulada \n de la severidad total")
# Center title
title.theme <- theme(plot.title = element_text(hjust = 0.5))

# Insert a horizontal line on y=1 because we are ploting a CDF
asinth.axis <- geom_hline(yintercept=1, size=.1)

# Color
if (colorImp) cdf.comp.pois.color="#ffa500" else cdf.comp.pois.color="black"

# Create layer
cdf.comp.pois.layer <- stat_function(
  aes(x=c(0,10)),
  fun=getValues.cdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  color=cdf.comp.pois.color
)

# Adjust scales on axes
cdf.xlim <- xlim(0,80000)
cdf.ylim <- ylim(0.88,1)

# Plot the standard CDF
p + xAxis + yAxis + cdf.comp.pois.labels + cdf.comp.pois.title + title.theme + asinth.axis + cdf.comp.pois.layer + cdf.xlim + cdf.ylim
```

La función de densidad de probabilidad de la severidad total está dada por
$$\begin{aligned}
  f_S(s) &= \frac{d}{ds}F_S(s)  \\
            &= \frac{d}{ds}\sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t \\
            &= \sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\frac{d}{ds}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t \\
            &= \sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!} \frac{\lambda_{exp}^n}{\Gamma (n)}s^{n-1}e^{-\lambda_{exp}s}
\end{aligned}$$

```{r plot S PDF, echo=FALSE, warning=FALSE}
# PDF Compound Poisson Distribution 
pdf.comp.pois <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.0000000001
  prob <- 0
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * dgamma(x, shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.pdf.comp.pois <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=pdf.comp.pois, lambda_po=lambda_po,lambda_exp=lambda_exp)

# Plot axes labels
pdf.comp.pois.labels <- labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))

# Title
pdf.comp.pois.title <- ggtitle("Función de densidad de probabilidad \n de la severidad total")

# Color
if (colorImp) pdf.comp.pois.color <- "violet" else pdf.comp.pois.color <- "black"

# Create layer
pdf.comp.pois.layer <- stat_function(
  aes(x=c(0,10)),
  fun=getValues.pdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  color=pdf.comp.pois.color
)

# Adjust scales on axes
pdf.xlim <- xlim(0,80000)
pdf.ylim <- ylim(0,.00001)

# Plot the standard PDF
p + xAxis + yAxis + pdf.comp.pois.labels + pdf.comp.pois.title + title.theme + pdf.comp.pois.layer + pdf.xlim + pdf.ylim
```

A continuación se presenta una tabla que indica la probabilidad que se acumula en ciertos puntos de la distribución de la severidad total:
```{r percentile table, echo=FALSE, warning=FALSE}
# Percentiles vector
percentiles <- c(0,1,50,100,1000,10000,20000,40000,50000)
probs <- sapply(percentiles, FUN=cdf.comp.pois, lambda_po=lambda_po, lambda_exp=lambda_exp)
percentiles.df <- data.frame(percentiles, probs)
names(percentiles.df) <- c("s","F(s)")
kable(percentiles.df)
```

Como se puede observar, casi toda la probabilidad se acumula en valores muy pequeños para la severidad total.

\section{1.2 Simulación}

Para hacer simulaciones de la severidad total, primero hay que simular el número $N$ de siniestros ocurridos, el cual proviene de la distribución de Poisson con media $\lambda_{Po}=`r lambda_po`$. Una vez simulado el número $N$ de sinistros, se simulan $N$ siniestros, que son variables aleatorias exponenciales con parámetros $\lambda_{exp}=1/`r denom`$. Después de obtener los $N$ siniestros, se suman y de esta manera se obtiene un primer valor de la severidad total. Para concluir con la simulación, se repite el proceso anterior $10000$ veces. A continuación se muestran los primeros $100$ valores obtenidos de la simulación:

```{r simulated values, echo=FALSE, warning=FALSE, message=FALSE}
severities <- c()
n <- 10000
for(i in 1:n) {
  N <- rpois(1,lambda=lambda_po)
  if (N != 0) {
    exps <- rexp(N, rate=lambda_exp)
    severities <- c(severities, sum(exps))
  } else {
    severities <- c(severities, 0)
  }
}
# Imprimiendo solo 100
severities[1:100]
```

El histograma debe parecerse a la función de densidad de probabilidad (la linea punteada indica la seveidad promedio):

```{r histogram, echo=FALSE, warning=FALSE}
if (colorImp) {
  hist.color <- "yellow3"
  hist.fill <- "yellow"
  hist.alpha <- "0.4"
} else {
  hist.color <- "black"
  hist.fill <- "white"
  hist.alpha <- "1"
}

severities.df <- data.frame(severities)
breaks <- seq(1, 80000, by=1000)
hist.p <- ggplot(data=severities.df, aes(x=severities)) +
  geom_histogram(breaks=breaks, color=hist.color, fill=hist.fill, alpha=hist.alpha) + 
  labs(x = TeX('Severidad total$'), y = TeX('Frecuencia')) +
  ggtitle("Histograma") + title.theme
hist.p
```

En la siguiente gráfica se puede apreciar que, en efecto, el histograma se parece a la función de densidad de probabilidad (notese el cambio de escala en el eje y):

```{r histogram with density, echo=FALSE, warning=FALSE}
# Plot the PDF with scaled histogram
# Create a plot
hist.den.p <- ggplot()
hist.p2 <- hist.den.p + xAxis + yAxis + pdf.comp.pois.labels + pdf.comp.pois.title + title.theme + pdf.xlim + pdf.ylim + geom_histogram(data=severities.df, aes(x=severities, y=.0000001*..count..), breaks=breaks, color=hist.color, fill=hist.fill, alpha=hist.alpha) + pdf.comp.pois.layer
hist.p2
# For more info about ploting density and histogram
# https://stat.ethz.ch/pipermail/r-help/2011-June/280588.html
```

\section{1.3 Comparación de los valores reales con los estimados}

Se vio que la severidad total, que sigue uns distribución de Poisson Compuesta, está dada por
$$  S=\sum_{i=1}^{N}x_i.$$
Entonces el valor esperado de la severidad total está dado por
$$\begin{aligned}
  E(S) &= E\left(\sum_{i=1}^{N}x_i\right)=E(E(S|N=n))=E\left(\sum_{i=1}^{n}x_i\bigg\rvert N=n\right)=E(NE(x_1))  \\
            &= E\left(N\left(\frac{1}{\lambda_{exp}}\right)\right)=\frac{1}{\lambda_{exp}E(N)}=\frac{\lambda_{exp}}{\lambda_{Po}}=\frac{10000}{0.1}=1000
\end{aligned}$$
y su varianza está dada por
$$\begin{aligned}
  Var(S) &= Var(E(S|N)) + E(Var(S|N)) = Var(NE(x_1))+E(NVar(x_1)) \\
            &=\frac{1}{\lambda_{exp}}Var(N) + \frac{1}{\lambda_{exp}^2}E(N) = \frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}=(10000)(0.1) + (10000)^2(0.1)=10001000
\end{aligned},$$
de manera que su desviaciÃ³n estandar es la siguinete:  
$$\sqrt{Var(S)}=\sqrt{10001000}=3162.43577.$$
La función generadora de momentos de $S$ esta dada por
$$M_{S}(t)=E\left(e^{N\ln\left(e^{x_{1}t}\right)}\right)=M_{N}(\ln\left(x_{1}t\right))=e^{\lambda_{Po}\left(\frac{\lambda_{exp}}{\lambda_{exp}+t}-1\right)} $$

se sigue que el sesgo de la distribución es positivo y está dado por
$$E\left((S-E(S))^3\right)=\lambda_{Po}E(x_1^3)=\lambda_{Po}M^{(3)}_{x_1}(0)=\lambda_{Po}\frac{6}{\lambda_{exp}^3}=(0.1)(6)(10000)^3=6\times 10^{11},$$
y el coeficiente de Kurtosis está dado por
$$ \frac{E(S^4)}{Var(S)^2}=\frac{M_{s}^{(4)}(0)}{\left(\frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}\right)^2}=\frac{\frac{\lambda_{Po}^4+12\lambda_{Po}^3+36\lambda_{Po}^2+24\lambda_{Po}}{\lambda_{exp}^4}}{10001000^2}=\frac{\frac{(0.1)^4+12(0.1)^3+36(0.1)^2+24(0.1)}{(1/10000)^4}}{10001000^2}=277.1545. $$

Con valores simulados se tienen las siguientes estimaciones para la severidad total

```{r comparando con valores estimados, echo=FALSE}
#value <- c("Media","Varianza","Sesgo","Kurtosis")
#formula <- c("$\\bar{s}=\\frac{1}{n}\\sum_{i=0}^{n}s_i$","$\\frac{1}{n-1}\\sum_{i=0}^{n}\\left(s_i-\\bar{s}\\right)$","${\\frac{{\\tfrac {1}{n}}\\sum _{i=1}^{n}(x_{i}-{\\overline{x}})^{3}}{\\left({\\tfrac {1}{n-1}}\\sum _{i=1}^{n}(x_{i}-{\\overline{x}})^{2}\\right)^{3/2}}}$","${\\frac{{\\tfrac{1}{n}}\\sum _{i=1}^{n}(s_{i}-{\\overline {s}})^{4}}{\\left({\\tfrac{1}{n}}\\sum _{i=1}^{n}(s_{i}-{\\overline {s}})^{2}\\right)^{2}}}-3$")
#real <- c(1000,10001000,"$6\\times10^{11}$",277.1545)
#estimate <- c(mean(severities),var(severities),skew(severities),kurtosis(severities))
#df.values <- data.frame(value, formula, estimate, real)
#names(df.values) <- c("Valor","FÃ³rmula","Estimado","Real")
#kable(df.values)
```

\section{1.4 Aproximación Gamma}

La función de distribución Poisson Compuesta pude ser aproximada mediante una distribución Gamma trasladada con los siguientes parámetros: 
$$\alpha=\frac{4\lambda_{Po}E\left(x_1^{2}\right)^3}{E\left(x_1^3\right)^2}=\frac{4\lambda_{Po}\left(\frac{2}{\lambda_{exp}^2}\right)^3}{\left(\frac{6}{\lambda_{exp}^3}\right)^2}=\frac{4}{45}, \quad \beta=\frac{2E\left(x_1^2\right)}{E\left(x_1^3\right)}=\frac{2\left(\frac{2}{\lambda_{exp}^2}\right)}{\left(\frac{6}{\lambda_{exp}^3}\right)}=\frac{1}{15000}$$

y un desplazamiento
$$x_0=\lambda_{Po}E\left(x_1\right)-\frac{2\lambda_{Po}E(x_1^2)^2}{E(x_1^3)}=\lambda_{Po}\left(\frac{1}{\lambda_{exp}}\right)-\frac{2\lambda_{Po}\left(\frac{2}{\lambda_{exp}^2}\right)^2}{\left(\frac{6}{\lambda_{exp}^3}\right)}=-\frac{1000}{3}$$
Observe que la aproximación es buena para valores distantes de la media de la distribución Poisson Compuesta: 
```{r densidad vs aproximacion gamma, echo=FALSE, warning=FALSE}
# PDF Gamma Trasladada
getValues.pdf.gamma.tras <- function(x, desp=1, alpha=4, beta=2) {
  dgamma(x-desp, shape = alpha, rate=beta)
}

# Stablish theme
comp.theme <- theme(
  #panel.grid.major = element_blank(), 
  #panel.grid.minor = element_blank(),
  #panel.background = element_blank(),
  
  # Legend position
  legend.position = c(1, 1),
  legend.justification = c("right", "top"),
  legend.box.just = "right",
  
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)

# Title
comp.title <- ggtitle("Densidad de la severidad total \n vs. \n aproximación")

# Number of different function to be ploted
types <- c("1","2")
# Create plot
comp.p <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
# Create layers
pdf.comp.pois.layer.path <- geom_path(
  data=data.frame(type="1"),
  stat="function",
  fun = getValues.pdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  aes(colour=type, linetype=type, size=type)
)
pdf.gam.layer <- stat_function(
  data=data.frame(type="2"),
  fun = getValues.pdf.gamma.tras,
  args = list(desp=-1000/3, alpha=4/45, beta=1/15000),
  aes(colour=type, linetype=type, size=type)
)
# Colors and line types
if (colorImp) {
  colors <- c(pdf.comp.pois.color,"red")
  sizes <- c(.5,.5)
  linetypes <-c(1,1)
} else {
  colors <- c("black", "black")
  sizes <- c(.5,.5)
  linetypes <-c(1,5)
}
# Legends
comp.an <- labs(TeX('Severidad total'), TeX('Aproximación Gamma'))

# Plot
comp.p + comp.theme + xAxis + yAxis + pdf.comp.pois.labels + comp.title + pdf.xlim + pdf.ylim + pdf.comp.pois.layer.path + pdf.gam.layer +
  scale_colour_manual(
    #name="Densidades", 
    name=NULL, 
    values=colors,
    labels = comp.an,
    breaks = types
  ) + 
  scale_linetype_manual(
    #name="Densidades", 
    name=NULL,
    values = linetypes,
    labels = comp.an,
    breaks = types
  ) +
  scale_size_manual(
    #name="Densidades", 
    name=NULL,
    values = sizes,
    labels = comp.an,
    breaks = types
  )

```
Para valores cercanos a la media es más conveniente aproximar la distribución Poisson Compuesta con una distribución Normal con los siguientes parámetros: 
$$\mu=E(N)E(X_1)=\frac{\lambda_{Po}}{\lambda_{exp}}=(0.1)(10000)=1000, $$
$$\sigma^2={E(x_1)}Var(N) + Var(x_1)E(N) = \frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}=(10000)(0.1) + (10000)^2(0.1)=10001000$$
Sin embargo, esto solo funciona para valores grandes de $\lambda_{Po}$. En el siguinete gráfico se muestra que la aproximación Normal para valores alrededor de la media es bastante mala, pues como $\lambda_{Po}$ es pequeña la media de la suma de variables aleatorias no corverge a la media de la aproximación Normal:

```{r densidad vs aproximacion normal, echo=FALSE, warning=FALSE}
# PDF Compound Poisson Distribution 
dpoiscomp <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.0000000001
  prob <- 0
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * dgamma(x, shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.pdf.pois.comp <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=dpoiscomp, lambda_po=lambda_po,lambda_exp=lambda_exp)

# PDF Gamma Trasladada
getValues.pdf.gamma.tras <- function(x, desp=1, alpha=4, beta=2) {
  dgamma(x-desp, shape = alpha, rate=beta)
}

# Create a plot
p <- ggplot()

# Stablish background and leyend position
theme <- theme(
  # Background
  #panel.grid.major = element_blank(), 
  #panel.grid.minor = element_blank(),
  #panel.background = element_blank(),
  
  # Legend position
  legend.position = c(1, 1),
  legend.justification = c("right", "top"),
  legend.box.just = "right",
  
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
# Plot axes to make it look nicer
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)

# Plot PDFs
# Labels
labels <- labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))
# Title
title <- ggtitle("Densidad de la severidad total \n vs. \n aproximación")
# Empty plot
# Number of different function to be ploted
types <- c("1","2")
# Create plot
p1 <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
# Create layers
pdf1 <- geom_path(
  data=data.frame(type="1"),
  stat="function",
  fun = getValues.pdf.pois.comp,
  args=list(lambda_po=0.1, lambda_exp=1/10000),
  aes(colour=type, linetype=type, size=type)
)
pdf2 <- stat_function(
  data=data.frame(type="2"),
  fun = dnorm,
  args = list(mean=1000, sd=sqrt((0.1)*(10000^2))),
  aes(colour=type, linetype=type, size=type)
)
# Colors and line types
if (colorImp) {
  colors <- c(pdf.comp.pois.color,"red")
  sizes <- c(.5,.5)
  linetypes <-c(1,1)
} else {
  colors <- c("black", "black")
  sizes <- c(.5,.5)
  linetypes <-c(1,5)
}
# Legends
an <- labs(TeX('Severidad total'), TeX('Aproximación Normal'))

# Plot
p1 + theme + xAxis + yAxis + labels + title + pdf.xlim + pdf.ylim + pdf1 + pdf2 +
  scale_colour_manual(
    #name="Densidades", 
    name=NULL, 
    values=colors,
    labels = an,
    breaks = types
  ) + 
  scale_linetype_manual(
    #name="Densidades", 
    name=NULL,
    values = linetypes,
    labels = an,
    breaks = types
  ) +
  scale_size_manual(
    #name="Densidades", 
    name=NULL,
    values = sizes,
    labels = an,
    breaks = types
  )
```

\section{2.3 Distribución empírica}

La distribución empírica de la severidad total está dada por

```{r, Preg. 2.3 Distribucion empirica de la severidad, echo=FALSE, warning=FALSE}
df <- data.frame(severities)
theme <- theme(
  # Center plot title
  plot.title = element_text(hjust = 0.5)
)
if (colorImp) emp.color <- "#add8e6" else emp.color <- "black"
ggplot() + stat_ecdf(data=df, aes(x=severities), geom = "step", color=emp.color) +
  labs(x = TeX('$s$'), y = TeX('$F_{S_n}(s)$')) + asinth.axis + xAxis + yAxis +
  ggtitle("Distribución empírica de la severidad total") + theme + cdf.ylim
```

Entonces un intervalo de confianza a un nivel de $(1-\alpha)100\%$ para distribución de la serveridad total $F_{S}(s)$ está dado por
$$\left(F_{s_n}(s)-\sqrt\frac{\ln\frac{2}{\alpha}}{2n}, F_{s_n}(s)+\sqrt\frac{\ln\frac{2}{\alpha}}{2n}\right)$$
Si se construyen los intervalos de confianza al $95\%$ para $F_S(s)$ utilizando la distribución empírica se tiene lo siguiente:
```{r, echo=FALSE, warning=FALSE}
Fn <- c(1:10000)
ordenados <- sort(severities)
alfa <- 0.05
limsup <- c(1:10000)
liminf <- c(1:10000)
for (i in 1:10000) {
  cuenta<-0
  for (j in 1:10000) {
    if (ordenados[j]<=ordenados[i]){
      cuenta=cuenta+1
    }
  }
  Fn[i] <- cuenta/10000
  limsup[i] <- Fn[i] + sqrt(log(2/alfa)/(2*10000))
  if (limsup[i] > 1) limsup[i] <- 1
  liminf[i] <- Fn[i] - sqrt(log(2/alfa)/(2*10000))
}
```

```{r, echo=FALSE, warning=FALSE}
types <- c("1","2","3","4")
p <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
theme <- theme(
  # Leyend position
  legend.position = c(1, 0),
  legend.justification = c("right", "bottom"),
  legend.box.just = "right",
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)
labels <- labs(x = TeX('$s$'), y = TeX('$F_{S_n}(s)$'))
title <- ggtitle("Intervalos de confianza al 95% para \n la distribución de la severidad total")

fun2 <- geom_step(data=data.frame(ordenados,limsup, type="1"), aes(x=ordenados, y=limsup, colour=type, linetype=type, size=type)) 
fun1 <- geom_step(data=data.frame(ordenados,Fn, type="3"), aes(x=ordenados, y=Fn, colour=type, linetype=type, size=type)) 
fun3 <- geom_step(data=data.frame(ordenados,liminf, type="4"), aes(x=ordenados, y=liminf, colour=type, linetype=type, size=type)) 
cdf.layer <- geom_path(
  data=data.frame(type="2"),
  stat="function",
  fun=getValues.cdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  aes(colour=type, linetype=type, size=type)
)
an <- labs(TeX('Cota superior'), TeX('Teórica'),TeX('Empírirca'), TeX('Cota inferior'))

if (colorImp) {
  colors <- c("#800080","#ffa500","#add8e6","purple")
  sizes <- c(.4,2,1,.4)
  linetypes <- c(1,1,1,1)
} else {
  colors <- c("black","black","black","black")
  sizes <- c(1,1,1,1)
  linetypes <-c(1,2,3,4)
}

p+theme+xAxis+yAxis+labels+title+cdf.layer+fun1+fun2+fun3+cdf.xlim+cdf.ylim+ asinth.axis +
scale_colour_manual(
  #name="Name",
  name = NULL,
  values = colors,
  labels = an,
  breaks = types
) +
scale_linetype_manual(
  #name="Name",
  name = NULL,
  values = linetypes,
  labels = an,
  breaks = types
) +
scale_size_manual(
  #name="Name",
  name = NULL,
  values = sizes,
  labels = an,
  breaks = types
)

```

\section{2.1 Simulación de los pares $\left(T_i,x_i\right)$}

Como la frecuencia de los eventos en un año se distribuye Poisson con media $\lambda_{Po}=`r lambda_po`$, entonces las diferencias de tiempo entre las ocurrencias de los eventos siguen una distribución exponencial con media $1/\lambda=\lambda_{Po}=`r lambda_po`$ de esta manera, media la simulación de variables aleatorias exponenciales se puden simular las fechas de ocurrencias de los siniestros. A continución se muestran las primeras $10$ realizaciones de las fechas de los siniestros y sus montos (tiempo medido en años):

```{r simulated pairs, echo=FALSE, warning=FALSE, message=FALSE}

rate   <- lambda_po
start  <- 2018
# Tiempo interarribos
per <- rexp(10000, rate=rate)
# Obtener las fechas de los cinistros
per[1] <- per[1]+start
# Fechas de los siniestros
PerTot <- cumsum(per)
# Montos de los siniestros
severities1 <- rexp(10000 ,rate=lambda_exp)
severities2 <- sort(unique(severities1))

convert.seconds <- function(x) {
  a <- x-2018
  b <- a*31556952
  c <- as.POSIXct(b, origin = "2018-01-01", tz = "UTC")
  as.character(c)
}
dates <- sapply(PerTot, convert.seconds)


pairs.df <- data.frame(dates, severities1)
names(pairs.df) <- c("Fechas", "Montos")
kable(head(pairs.df, 10))
```

A continuación se muestra la serie de tiempo generada

```{r, serie de tiempo, echo=FALSE}
# Ploting time series
# https://www.neonscience.org/dc-time-series-plot-ggplot-r
fechonsias <- pairs.df[[1]]
funciononsia <- function(x) {
  value <- NA
  if (match(x,fechonsias) %% 500 !=0) {
    value <- NA
  } else {
    fechaSeparada <- strsplit(as.character(x), " ")
    value <- fechaSeparada[[1]][1]
  }
  value
}
fechunias <- sapply(fechonsias, funciononsia)
montunios <- pairs.df[[2]]
dfonsio <- data.frame(fechunias, montunios)
names(dfonsio) <- c("fechonson", "montonson")

ggplot(data = dfonsio, aes(x = c(1:10000), y = montonson, group = 1)) + 
  geom_bar(stat="identity", color = "#00AFBB", size = .1, alpha=.1, na.rm = TRUE) +
  geom_point(size=.005, color="blue", alpha=0.5) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size=5)) + 
  scale_x_discrete(limits=dfonsio[[1]], na.translate = FALSE) + xlab("Fecha") + ylab("Monto") + 
  geom_hline(yintercept=1000, size=.5, color="green")
```