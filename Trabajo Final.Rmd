---
title: "Trabajo final de C谩lculo Actuarial III"
author: "Bernardo Mondrag贸n Brozon"
date: "May 12, 2018"
output: pdf_document 
---

<!-- Configure R Markdown file -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Define the size of the graphs
knitr::opts_chunk$set(fig.width=4.5, fig.height=3, fig.align = "center") 
```







\section{La severidad total}

La severidad total est谩 dada por lo siguiente:
$$ S=x_1+x_2+\cdots+x_N  $$
En donde $\{x_i\}_{i=1\dots N}$ son variables aleatorias independientes e id茅nticamente distribuidas que indican los montos tal que $x_i$ sigue una distribuci贸n exponencial con media $1/\lambda_{exp}=10000$ para toda $i$, y $N$ es la variable aleatoria independiente de las $x_i$'s que indica la frecuencia de los montos tal que sigue una distribuci贸n de Poisson con media $\lambda_{Po}=0.1$ eventos en un a帽o.  

Por el teorema de probabilidad total se tiene que 
$$Pr\{S\leq s | N=n \}=\frac{Pr\{S\leq s , N=n \}}{Pr\{N=n \}}  $$
$$  \Rightarrow \quad Pr\{S\leq s , N=n \}=Pr\{N=n \}Pr\{S\leq s | N=n \}$$
Por lo tanto se tiene que 
$$\begin{aligned}
  F_S(s) &= \sum_{n=0}^{\infty}Pr\{S\leq s, N=n\}  \\
            &= \sum_{n=0}^{\infty}Pr\{N=n \}Pr\{S\leq s | N=n \} \\
            &= \sum_{n=0}^{\infty}Pr\{N=n \}Pr\{\sum_{i=n}^{N}x_i  \leq s |N=n \} \\
            &= \sum_{n=0}^{\infty}Pr\{N=n \}F_X^{*n}(s)
\end{aligned}$$
En donde $F_X^{*n}(s)$ es la convoluci贸n de las variables aleatorias $\{x_i\}_{i=1\dots N}$, o bien, la funci贸n de distribucion de probabilidad acumulada de $\sum_{i=n}^{N}x_i$ con $x_i \sim exp(\lambda_{exp}=1/10000)$. Sean $M_{\sum_{i=n}^{N}x_i}(t)$ y $M_{x_1}(t)$ las funciones generadoras de momentos de las variables aleatorias $\sum_{i=n}^{N}x_i$ y $x_1$ respectivamente, entonces, sin p茅rdida de generalidad, se tiene que
$$M_{\sum_{i=n}^{N}x_i}(t)=\prod_{i=1}^n M_{x_1}(t)=\prod_{i=1}^n\frac{\lambda_{exp}}{\lambda_{exp}+t}=\left(\frac{\lambda_{exp}}{\lambda_{exp}+t}\right)^n=\left(1-\frac{t}{\lambda_{exp}}\right)^{-n}$$
Lo cual corresponde a la funci贸n generadora de momentos de una variable aleatoria distribuida Gamma con par谩metros de $\alpha = n$ y $\beta = \lambda_{exp}$. Adem谩s, la distribuci贸n de la frecuencia es Poisson con par谩metro $\lambda_{Po}=0.1$, entonces se sigue que
$$F_S(s)=\sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t $$
```{r plot CDF, echo=FALSE, warning=FALSE}
library(ggplot2)
# Include package latex2exp so you can put latex in labels
library(latex2exp)
# CDF Compound Poisson Distribution 
cdf <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.000001
  
  # Define the region of integration
  B <- c(0, x)
  
  # Calculate the sum
  # prob starts in zero because the severity is a positive random variable
  # First term
  prob <- 0 
  if (B[1] == 0) prob <- exp(-lambda_po)
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * pgamma(B[2], shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=cdf, lambda_po=lambda_po,lambda_exp=lambda_exp)


# Create a plot
p <- ggplot()

# Plot axes to make it look nicer
xAxis <- geom_hline(yintercept = 0, size = .5)
yAxis <-geom_vline(xintercept = 0, size = .5)

# Plot axes labels
labels <- labs(x = TeX('$s$'), y = TeX('$F_S(s)$'))
# Title
title <- ggtitle("Funci贸n de probabilidad acumulada \n de la severidad total")
theme <- theme(plot.title = element_text(hjust = 0.5))

# Insert a horizontal line on y=1 because we are ploting a CDF
asinth.axis <- geom_hline(yintercept=1, size=.1)

# Plot the standard CDF
# Color
bw <- TRUE
if (bw) color = "black" else color = "greenyellow"
# Create layer
lambda_po <- 0.1
lambda_exp <- 1/10000
cdf.layer <- stat_function(
  aes(x=c(0,10)),
  fun =getValues,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  color = color
)
# Adjust scales on axes
xlim <- xlim(0,80000)
ylim <- ylim(0.857,1)
# Plot the standard CDF
p + xAxis + yAxis + labels + title + theme + asinth.axis + cdf.layer + xlim + ylim
```













La funci贸n de densidad de probabilidad de la severidad total esta dada por
$$\begin{aligned}
  f_S(s) &= \frac{d}{ds}F_S(s)  \\
            &= \frac{d}{ds}\sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t \\
            &= \sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\frac{d}{ds}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t \\
            &= \sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!} \frac{\lambda_{exp}^n}{\Gamma (n)}s^{n-1}e^{-\lambda_{exp}s}
\end{aligned}$$
```{r plot PDF, echo=FALSE, warning=FALSE}
# PDF Compound Poisson Distribution 
pdf <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.0000000001
  prob <- 0
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * dgamma(x, shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.pdf <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=pdf, lambda_po=lambda_po,lambda_exp=lambda_exp)

# Plot axes labels
labels.pdf <- labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))
# Title
title.pdf <- ggtitle("Funci贸n de densidad de probabilidad \n de la severidad total")

# Create layer
pdf.layer <- stat_function(
  aes(x=c(0,10)),
  fun=getValues.pdf,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  color = color
)
# Adjust scales on axes
xlim.pdf <- xlim(0,80000)
ylim.pdf <- ylim(0,.00001)
# Plot the standard PDF
p + xAxis + yAxis + labels.pdf + title.pdf + theme + pdf.layer + xlim.pdf + ylim.pdf
```










A continuaci贸n se presenta una tabla que indica la probabilidad que se acumula en ciertos puntos de la distribuci贸n de la severidad total:
```{r table, echo=FALSE, warning=FALSE}
# Quantile vector
quantiles <- c(0,1,50,100,1000,10000,20000,40000,50000)
probs <- sapply(quantiles, FUN=cdf)
df1 <- data.frame(quantiles, probs)
names(df1) <- c("s","F(s)")
library(knitr)
library(kableExtra)
kable(df1)
#kable_styling(latex_options = c("striped"))
```


Como se puede observar, casi toda la probabilidad se acumula en valores muy peque帽os para la severidad total.












\section{Simulaci贸n}

Para hacer simulaciones de la severidad total, primero hay que simular el n煤mero $N$ de siniestros ocurridos, el cual proviene de la distribuci贸n de Poisson con media $\lambda_{Po}=0.1$. Una vez simulado el n煤mero $N$ de sinistros, se simulan $N$ siniestros, que son variables aleatorias exponenciales con par谩metro $\lambda_{exp}=1/10000$. Despu茅s de obtener los $N$ sinistros, se suman y de esta manera se obtiene un primer valor de la severidad total. Para concluir con la simulaci贸n, se repite el proceso anterior $10000$ veces. A continuaci贸n se muestran los primeros $100$ valores obtenidos de la simulaci贸n:
```{r simulated values, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
lambda_po <- 0.1
lambda_exp <- 1/10000
severities <- c()
n <- 10000
for(i in 1:n) {
  N <- rpois(1,lambda=lambda_po)
  if (N != 0) {
    exps <- rexp(N, rate=lambda_exp)
    severities <- c(severities, sum(exps))
  } else {
    severities <- c(severities, 0)
  }
}
# Imprimiendo solo 100
severities[1:100]
```

El histograma debe parecerse a la funci贸n de densidad de probabilidad (la linea punteada indica la seveidad promedio):
```{r histogram, echo=FALSE, warning=FALSE}
# Plot histogram
df <- data.frame(severities)
breaks <- seq(1, 80000, by=1000)
p1 <- ggplot(data=df, aes(x=severities)) +
  geom_histogram(breaks=breaks, color="black", fill="white") +
  #geom_density(aes(y=200*..count..), color="black", adjust=28) +
  geom_vline(aes(xintercept=mean(severities)), color="black", linetype=5,    size=1) + 
  labs(x = TeX('$Severidad$'), y = TeX('$Frecuencia$')) +
  ggtitle("Histograma") +
  theme(plot.title=element_text(hjust=0.5))
```

```{r histogram with density, echo=FALSE, warning=FALSE}
# Plot the standard PDF with scaled histogram
p2 <- p + xAxis + yAxis + labels.pdf + title.pdf + theme + xlim.pdf + ylim.pdf + geom_histogram(data=df, aes(x=severities, y=.0000001*..count..), breaks=breaks, color="black", fill="white") + pdf.layer

p1
p2
# For more info about ploting density and histogram
# https://stat.ethz.ch/pipermail/r-help/2011-June/280588.html
```

Se vio que la severidad total, que sigue uns distribuci贸n de Poisson Compuesta, est谩 dada por
$$  S=\sum_{i=1}^{N}x_i.$$
Entonces el valor esperado de la severidad total est谩 dado por
$$\begin{aligned}
  E(S) &= E\left(\sum_{i=1}^{N}x_i\right)=E(E(S|N=n))=E\left(\sum_{i=1}^{n}x_i\bigg\rvert N=n\right)=E(NE(x_1))  \\
            &= E\left(N\left(\frac{1}{\lambda_{exp}}\right)\right)=\frac{1}{\lambda_{exp}E(N)}=\frac{\lambda_{exp}}{\lambda_{Po}}=\frac{10000}{0.1}=1000
\end{aligned}$$
y su varianza est谩 dada por
$$\begin{aligned}
  Var(S) &= Var(E(S|N)) + E(Var(S|N)) = Var(NE(x_1))+E(NVar(x_1)) \\
            &=\frac{1}{\lambda_{exp}}Var(N) + \frac{1}{\lambda_{exp}^2}E(N) = \frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}=(10000)(0.1) + (10000)^2(0.1)=10001000
\end{aligned},$$
de manera que su desviaci贸n estandar es la siguinete:  
$$\sqrt{Var(S)}=\sqrt{10001000}=3162.43577.$$
La funci贸n generadora de momentos de $S$ esta dada por
$$M_{S}(t)=E\left(e^{N\ln\left(e^{x_{1}t}\right)}\right)=M_{N}(\ln\left(x_{1}t\right))=e^{\lambda_{Po}\left(\frac{\lambda_{exp}}{\lambda_{exp}+t}-1\right)} $$

se sigue que el sesgo de la distribuci贸n es positivo y est谩 dado por
$$E\left((S-E(S))^3\right)=\lambda_{Po}E(x_1^3)=\lambda_{Po}M^{(3)}_{x_1}(0)=\lambda_{Po}\frac{6}{\lambda_{exp}^3}=(0.1)(6)(10000)^3=6\times 10^{11},$$
y el coeficiente de Kurtosis est谩 dado por
$$ \frac{E(S^4)}{Var(S)^2}=\frac{M_{s}^{(4)}(0)}{\left(\frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}\right)^2}=\frac{\frac{\lambda_{Po}^4+12\lambda_{Po}^3+36\lambda_{Po}^2+24\lambda_{Po}}{\lambda_{exp}^4}}{10001000^2}=\frac{\frac{(0.1)^4+12(0.1)^3+36(0.1)^2+24(0.1)}{(1/10000)^4}}{10001000^2}=277.1545. $$
\section{Comparando con los valores estimados}

Con valores simulados se tienen las siguientes estimaciones para la severidad total
```{r comparando con valores estimados, echo=FALSE}
library(moments)
#value <- c("Media","Varianza","Sesgo","Kurtosis")
#formula <- c("$\\bar{s}=\\frac{1}{n}\\sum_{i=0}^{n}s_i$","$\\frac{1}{n-1}\\sum_{i=0}^{n}\\left(s_i-\\bar{s}\\right)$","${\\frac{{\\tfrac {1}{n}}\\sum _{i=1}^{n}(x_{i}-{\\overline{x}})^{3}}{\\left({\\tfrac {1}{n-1}}\\sum _{i=1}^{n}(x_{i}-{\\overline{x}})^{2}\\right)^{3/2}}}$","${\\frac{{\\tfrac{1}{n}}\\sum _{i=1}^{n}(s_{i}-{\\overline {s}})^{4}}{\\left({\\tfrac{1}{n}}\\sum _{i=1}^{n}(s_{i}-{\\overline {s}})^{2}\\right)^{2}}}-3$")
#real <- c(1000,10001000,"$6\\times10^{11}$",277.1545)
#estimate <- c(mean(severities),var(severities),skew(severities),kurtosis(severities))
#df.values <- data.frame(value, formula, estimate, real)
#names(df.values) <- c("Valor","F贸rmula","Estimado","Real")
#kable(df.values)
```
\section{Aproximacin Gamma}

La funcin de distribucin Poisson Compuesta pude ser aproximada mediante una distribucin Gamma trasladada con los siguientes parmetros: 
$$\alpha=\frac{4\lambda_{Po}E\left(x_1^{2}\right)^3}{E\left(x_1^3\right)^2}=\frac{4\lambda_{Po}\left(\frac{2}{\lambda_{exp}^2}\right)^3}{\left(\frac{6}{\lambda_{exp}^3}\right)^2}=\frac{4}{45}, \quad \beta=\frac{2E\left(x_1^2\right)}{E\left(x_1^3\right)}=\frac{2\left(\frac{2}{\lambda_{exp}^2}\right)}{\left(\frac{6}{\lambda_{exp}^3}\right)}=\frac{1}{15000}$$

y un desplazamiento
$$x_0=\lambda_{Po}E\left(x_1\right)-\frac{2\lambda_{Po}E(x_1^2)^2}{E(x_1^3)}=\lambda_{Po}\left(\frac{1}{\lambda_{exp}}\right)-\frac{2\lambda_{Po}\left(\frac{2}{\lambda_{exp}^2}\right)^2}{\left(\frac{6}{\lambda_{exp}^3}\right)}=-\frac{1000}{3}$$

```{r}

getValues.pdf.gamma <- function(x, desp=1, alpha=4, beta=2) {
  dgamma(x-desp, shape = alpha, rate=beta)
}

# Create a plot
p <- ggplot()
p

# Get rid of the grey background
theme <- theme(
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(),
  panel.background = element_blank(),
  # Legend boxes
  legend.key = element_rect(colour = 'white', fill = 'white', size = 0.5, linetype='dashed'),
  # Legend position
  legend.position = c(0.25, 0.5)
)
p + theme

# Plot axes to make it look nicer
xAxis <- geom_hline(yintercept = 0, size = .001)
yAxis <-geom_vline(xintercept = 0, size = .001)
p + theme + xAxis + yAxis

# Plot axes labels
labels <- labs(x = "x", y = "f(x) : Weibull PDF")
p + theme + xAxis + yAxis + labels

# Plot the standard CDF
# Color
bw <- TRUE
if (bw) color = "black" else color = "greenyellow"
# Adjust scales on axes
xlim <- xlim(0,80000)
ylim <- ylim(0,.00001)
# Plot the standard CDF preserving the scale on axes
p + theme + xAxis + yAxis + labels + xlim + ylim + coord_fixed()


# Plot the PDF with various parameters
# Create plor
types <- c("1","2")
p1 <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
# Create layers
pdf1 <- stat_function(
  data=data.frame(type="1"),
  fun=getValues.pdf,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  aes(colour=type, linetype=type, size=type)
)
pdf2 <- stat_function(
  data=data.frame(type="2"),
  fun=getValues.pdf.gamma,
  args = list(desp = -1000/3, alpha = .08, beta = 1/15000),
  aes(colour=type, linetype=type, size=type)
)
# Colors and line types
if (bw) {
  colors <- c("black", "black")
  sizes <- c(.5,.7)
  linetypes <-c(1,2)
} else {
  colors <- c("greenyellow","green1")
  sizes <- c(.5,.5)
  linetypes <-c(1,1)
}
# Legends
an <- c("\u03B1 = 1; \u03BC = 0; \u03B8 = 1",
        "\u03B1 = 2; \u03BC = 0; \u03B8 = 1")
# Plot
p1 + theme + xAxis + yAxis + labels + xlim + ylim + pdf1 + pdf2 +
  scale_colour_manual(
    name="Functions", 
    values=colors,
    labels = an,
    breaks = types
  ) + 
  scale_linetype_manual(
    name="Functions",
    values = linetypes,
    labels = an,
    breaks = types
  ) +
  scale_size_manual(
    name="Functions",
    values = sizes,
    labels = an,
    breaks = types
  )
```