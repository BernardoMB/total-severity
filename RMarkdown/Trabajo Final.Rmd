---
title: "Trabajo final de Calculo Actuarial III"
author: "Bernardo Mondragon Brozon, Anjara Rueda"
date: "May 12, 2018"
output: pdf_document
---

<!-- Configure R Markdown file -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Create beautiful graphs
#install.packages("ggplot")
library(ggplot2)
# TeX expressions in graphs labels
#install.packages("latex2exp")
library(latex2exp)
# Calculate Kurtosis skew and other functions
#install.packages("moments")
library(moments)
# Para knitear
#install.packages("knitr")
library(knitr)
# Para imprimir tablas
#install.packages("kableExtra")
library(kableExtra)

# Color?
colorImp <- TRUE
```

\section{El modelo colectivo}

\subsection{1.1 La severidad total}

La severidad total esta dada por lo siguiente:
$$ S=x_1+x_2+\cdots+x_N  $$
```{r, parameters, include=FALSE}
lambda_po <- 0.1
denom <- 10000 # Por la parametrizacion de la exponencial
lambda_exp <- 1/denom
```
En donde $\{x_i\}_{i=1\dots N}$ son variables aleatorias independientes e identicamente distribuidas que indican los montos tal que $x_i$ sigue una distribucion exponencial con media $1/\lambda_{exp}=`r denom`$ para toda $i$, y $N$ es la variable aleatoria independiente de las $x_i$'s que indica la frecuencia de los montos tal que sigue una distribucion de Poisson con media $\lambda_{Po}=`r lambda_po`$ eventos en un ano.

Por el teorema de probabilidad total se tiene que 
$$Pr\{S\leq s|N=n\}=\frac{Pr\{S\leq s,N=n\}}{Pr\{N=n\}}  $$
$$\Rightarrow \quad Pr\{S\leq s,N=n\}=Pr\{N=n\}Pr\{S\leq s|N=n\}.$$
Por lo tanto se tiene que 
$$\begin{aligned}
  F_S(s) &= \sum_{n=0}^{\infty}Pr\{S\leq s,N=n\}  \\
            &= \sum_{n=0}^{\infty}Pr\{N=n\}Pr\{S\leq s|N=n\} \\
            &= \sum_{n=0}^{\infty}Pr\{N=n\}Pr\{\sum_{i=n}^{N}x_i\leq s|N=n\} \\
            &= \sum_{n=0}^{\infty}Pr\{N=n\}F_X^{*n}(s).
\end{aligned}$$

En donde $F_X^{*n}(s)$ es la convolucion de las variables aleatorias $\{x_i\}_{i=1\dots N}$, o bien, la funcion de distribucion de probabilidad acumulada de $\sum_{i=n}^{N}x_i$ con $x_i \sim exp(\lambda_{exp}=1/`r  denom`)$. 
Sean $M_{\sum_{i=n}^{N}x_i}(t)$ y $M_{x_1}(t)$ las funciones generadoras de momentos de las variables aleatorias $\sum_{i=n}^{N}x_i$ y $x_1$ respectivamente, entonces, sin pÃ©rdida de generalidad, se tiene que

$$M_{\sum_{i=n}^{N}x_i}(t)=\prod_{i=1}^n M_{x_1}(t)=\prod_{i=1}^n\frac{\lambda_{exp}}{\lambda_{exp}+t}=\left(\frac{\lambda_{exp}}{\lambda_{exp}+t}\right)^n=\left(1-\frac{t}{\lambda_{exp}}\right)^{-n}.$$

Lo cual corresponde a la funcion generadora de momentos de una variable aleatoria distribuida Gamma con parametros de $\alpha = n$ y $\beta = \lambda_{exp}$. Ademas, la distribucion de la frecuencia es Poisson con parametros $\lambda_{Po}=`r lambda_po`$, entonces se sigue que
$$F_S(s)=\sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t $$
```{r plot S CDF, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
# CDF Compound Poisson Distribution 
cdf.comp.pois <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.000001
  
  # Define the region of integration
  B <- c(0, x)
  
  # Calculate the sum
  # prob starts in zero because the severity is a positive random variable
  # First term
  prob <- 0 
  if (B[1] == 0) prob <- exp(-lambda_po)
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * pgamma(B[2], shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.cdf.comp.pois <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=cdf.comp.pois, lambda_po=lambda_po,lambda_exp=lambda_exp)

# Create a plot
p <- ggplot()

# Plot axes to make it look nicer
xAxis <- geom_hline(yintercept = 0, size = .5)
yAxis <-geom_vline(xintercept = 0, size = .5)

# Plot axes labels
cdf.comp.pois.labels <- labs(x = TeX('$s$'), y = TeX('$F_S(s)$'))
# Title
cdf.comp.pois.title <- ggtitle("funcion de probabilidad acumulada \n de la severidad total")
# Center title
title.theme <- theme(plot.title = element_text(hjust = 0.5))

# Insert a horizontal line on y=1 because we are ploting a CDF
asinth.axis <- geom_hline(yintercept=1, size=.1)

# Color
if (colorImp) cdf.comp.pois.color="#ffa500" else cdf.comp.pois.color="black"

# Create layer
cdf.comp.pois.layer <- stat_function(
  aes(x=c(0,10)),
  fun=getValues.cdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  color=cdf.comp.pois.color
)

# Adjust scales on axes
cdf.xlim <- xlim(0,80000)
cdf.ylim <- ylim(0.88,1)

# Plot the standard CDF
p + xAxis + yAxis + cdf.comp.pois.labels + cdf.comp.pois.title + title.theme + asinth.axis + cdf.comp.pois.layer + cdf.xlim + cdf.ylim
```
Se tiene que
$$\begin{aligned}
  \frac{d}{ds}F_S(s) &= \frac{d}{ds}\sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t \\
            &= \sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!}\frac{d}{ds}\int_0^s \frac{\lambda_{exp}^n}{\Gamma (n)}t^{n-1}e^{-\lambda_{exp}t} \, \mathrm{d}t \\
            &= \sum_{n=0}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!} \frac{\lambda_{exp}^n}{\Gamma (n)}s^{n-1}e^{-\lambda_{exp}s}
\end{aligned}$$

Si la severidad total es cero es porque no ocurrieron siniestros, mas no porque todos los montos fueron cero, entonces la funcion de densidad de probabilidad de la severidad total tiene una modificacion en cero, de manera que la densidad es una mezcla de una distribucion degenerada con toda la probabilidad concentrada en cero y una distribucion Poisson Compuesta empezando con $N$ al menos un siniestros, entonces
$$f_S(s) = e^{-\lambda_{Po}} + \sum_{n=1}^{\infty}\frac{\lambda_{Po}^n e^{-\lambda_{Po}}}{n!} \frac{\lambda_{exp}^n}{\Gamma (n)}s^{n-1}e^{-\lambda_{exp}s} $$


```{r plot S PDF, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
# PDF Compound Poisson Distribution 
pdf.comp.pois <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.0000000001
  prob <- 0
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * dgamma(x, shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.pdf.comp.pois <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=pdf.comp.pois, lambda_po=lambda_po,lambda_exp=lambda_exp)

# Plot axes labels
pdf.comp.pois.labels <- labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))

# Title
pdf.comp.pois.title <- ggtitle("funcion de densidad de probabilidad \n de la severidad total")

# Color
if (colorImp) pdf.comp.pois.color <- "violet" else pdf.comp.pois.color <- "black"

# Create layer
pdf.comp.pois.layer <- stat_function(
  aes(x=c(0,10)),
  fun=getValues.pdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  color=pdf.comp.pois.color
)

# Adjust scales on axes
pdf.xlim <- xlim(0,80000)
pdf.ylim <- ylim(0,.00001)

# Plot the standard PDF
p + xAxis + yAxis + pdf.comp.pois.labels + pdf.comp.pois.title + title.theme + pdf.comp.pois.layer + pdf.xlim + pdf.ylim
```

A continuacion se presenta una tabla que indica la probabilidad que se acumula en ciertos puntos de la distribucion de la severidad total:
```{r percentile table, echo=FALSE, warning=FALSE}
# Percentiles vector
percentiles <- c(0,1,50,100,1000,10000,20000,40000,50000)
probs <- sapply(percentiles, FUN=cdf.comp.pois, lambda_po=lambda_po, lambda_exp=lambda_exp)
percentiles.df <- data.frame(percentiles, probs)
names(percentiles.df) <- c("s","F(s)")
kable(percentiles.df)
```

Como se puede observar, casi toda la probabilidad se acumula en valores muy pequeÃ±os para la severidad total.

\subsection{1.2 simulacion}

Para hacer simulaciones de la severidad total, primero hay que simular el numero $N$ de siniestros ocurridos, el cual proviene de la distribucion de Poisson con media $\lambda_{Po}=`r lambda_po`$. Una vez simulado el numero $N$ de sinistros, se simulan $N$ siniestros, que son variables aleatorias exponenciales con parametros $\lambda_{exp}=1/`r denom`$. Despues de obtener los $N$ siniestros, se suman y de esta manera se obtiene un primer valor de la severidad total. Para concluir con la simulacion, se repite el proceso anterior $10000$ veces. A continuacion se muestran los primeros $100$ valores obtenidos de la simulacion:

```{r simulated values, echo=FALSE, warning=FALSE, message=FALSE}
severities <- c()
n <- 10000
for(i in 1:n) {
  N <- rpois(1,lambda=lambda_po)
  if (N != 0) {
    exps <- rexp(N, rate=lambda_exp)
    severities <- c(severities, sum(exps))
  } else {
    severities <- c(severities, 0)
  }
}
# Imprimiendo solo 100
severities[1:100]
```

El histograma debe parecerse a la funcion de densidad de probabilidad:

```{r histogram, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
if (colorImp) {
  hist.color <- "pink"
  hist.fill <- "pink3"
  hist.alpha <- "0.4"
} else {
  hist.color <- "black"
  hist.fill <- "white"
  hist.alpha <- "1"
}

severities.df <- data.frame(severities)
breaks <- seq(1, 80000, by=1000)
hist.p <- ggplot(data=severities.df, aes(x=severities)) +
  geom_histogram(breaks=breaks, color=hist.color, fill=hist.fill, alpha=hist.alpha) + 
  labs(x = TeX('Severidad total$'), y = TeX('Frecuencia')) +
  ggtitle("Histograma") + title.theme
hist.p
```

En la siguiente grafica se puede apreciar que, en efecto, el histograma se parece a la funcion de densidad de probabilidad (notese el cambio de escala en el eje y):

```{r histogram with density, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
# Plot the PDF with scaled histogram
# Create a plot
hist.den.p <- ggplot()
hist.p2 <- hist.den.p + xAxis + yAxis + pdf.comp.pois.labels + pdf.comp.pois.title + title.theme + pdf.xlim + pdf.ylim + geom_histogram(data=severities.df, aes(x=severities, y=.0000001*..count..), breaks=breaks, color=hist.color, fill=hist.fill, alpha=hist.alpha) + pdf.comp.pois.layer
hist.p2
# For more info about ploting density and histogram
# https://stat.ethz.ch/pipermail/r-help/2011-June/280588.html
```

\subsection{1.3 Comparacion de los valores reales con los estimados}

Se vio que la severidad total, que sigue uns distribucion de Poisson Compuesta, esta dada por
$$  S=\sum_{i=1}^{N}x_i.$$
Entonces el valor esperado de la severidad total esta dado por
$$\begin{aligned}
  E(S) &= E\left(\sum_{i=1}^{N}x_i\right)=E(E(S|N=n))=E\left(\sum_{i=1}^{n}x_i\bigg\rvert N=n\right)=E(NE(x_1))  \\
            &= E\left(N\left(\frac{1}{\lambda_{exp}}\right)\right)=\frac{1}{\lambda_{exp}E(N)}=\frac{\lambda_{exp}}{\lambda_{Po}}=\frac{10000}{0.1}=1000
\end{aligned}$$
y su varianza esta dada por
$$\begin{aligned}
  Var(S) &= Var(E(S|N)) + E(Var(S|N)) = Var(NE(x_1))+E(NVar(x_1)) \\
            &=\frac{1}{\lambda_{exp}}Var(N) + \frac{1}{\lambda_{exp}^2}E(N) = \frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}=(10000)(0.1) + (10000)^2(0.1)=10001000
\end{aligned},$$
de manera que su desviacion estandar es la siguinete:  
$$\sqrt{Var(S)}=\sqrt{10001000}=3162.43577.$$
La funcion generadora de momentos de $S$ esta dada por
$$M_{S}(t)=E\left(e^{N\ln\left(e^{x_{1}t}\right)}\right)=M_{N}(\ln\left(x_{1}t\right))=e^{\lambda_{Po}\left(\frac{\lambda_{exp}}{\lambda_{exp}+t}-1\right)} $$

se sigue que el sesgo de la distribucion es positivo y esta dado por
$$E\left((S-E(S))^3\right)=\lambda_{Po}E(x_1^3)=\lambda_{Po}M^{(3)}_{x_1}(0)=\lambda_{Po}\frac{6}{\lambda_{exp}^3}=(0.1)(6)(10000)^3=6\times 10^{11},$$
y el coeficiente de Kurtosis esta dado por
$$ \frac{E(S^4)}{Var(S)^2}=\frac{M_{s}^{(4)}(0)}{\left(\frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}\right)^2}=\frac{\frac{\lambda_{Po}^4+12\lambda_{Po}^3+36\lambda_{Po}^2+24\lambda_{Po}}{\lambda_{exp}^4}}{10001000^2}=\frac{\frac{(0.1)^4+12(0.1)^3+36(0.1)^2+24(0.1)}{(1/10000)^4}}{10001000^2}=277.1545. $$

Con valores simulados se tienen las siguientes estimaciones para la severidad total

```{r comparando con valores estimados, echo=FALSE}
#value <- c("Media","Varianza","Sesgo","Kurtosis")
#formula <- c("$\\bar{s}=\\frac{1}{n}\\sum_{i=0}^{n}s_i$","$\\frac{1}{n-1}\\sum_{i=0}^{n}\\left(s_i-\\bar{s}\\right)$","${\\frac{{\\tfrac {1}{n}}\\sum _{i=1}^{n}(x_{i}-{\\overline{x}})^{3}}{\\left({\\tfrac {1}{n-1}}\\sum _{i=1}^{n}(x_{i}-{\\overline{x}})^{2}\\right)^{3/2}}}$","${\\frac{{\\tfrac{1}{n}}\\sum _{i=1}^{n}(s_{i}-{\\overline {s}})^{4}}{\\left({\\tfrac{1}{n}}\\sum _{i=1}^{n}(s_{i}-{\\overline {s}})^{2}\\right)^{2}}}-3$")
#real <- c(1000,10001000,"$6\\times10^{11}$",277.1545)
#estimate <- c(mean(severities),var(severities),skew(severities),kurtosis(severities))
#df.values <- data.frame(value, formula, estimate, real)
#names(df.values) <- c("Valor","Formula","Estimado","Real")
#kable(df.values)
```

\subsection{1.4 Aproximacion de la distribucion de la severidad total}

La funcion de distribucion Poisson Compuesta pude ser aproximada mediante una distribucion Gamma trasladada con los siguientes parametros: 
$$\alpha=\frac{4\lambda_{Po}E\left(x_1^{2}\right)^3}{E\left(x_1^3\right)^2}=\frac{4\lambda_{Po}\left(\frac{2}{\lambda_{exp}^2}\right)^3}{\left(\frac{6}{\lambda_{exp}^3}\right)^2}=\frac{4}{45}, \quad \beta=\frac{2E\left(x_1^2\right)}{E\left(x_1^3\right)}=\frac{2\left(\frac{2}{\lambda_{exp}^2}\right)}{\left(\frac{6}{\lambda_{exp}^3}\right)}=\frac{1}{15000}$$

y un desplazamiento
$$x_0=\lambda_{Po}E\left(x_1\right)-\frac{2\lambda_{Po}E(x_1^2)^2}{E(x_1^3)}=\lambda_{Po}\left(\frac{1}{\lambda_{exp}}\right)-\frac{2\lambda_{Po}\left(\frac{2}{\lambda_{exp}^2}\right)^2}{\left(\frac{6}{\lambda_{exp}^3}\right)}=-\frac{1000}{3}$$
Observe que la aproximacion es buena para valores distantes de la media de la distribucion Poisson Compuesta: 
```{r densidad vs aproximacion gamma, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
# PDF Gamma Trasladada
getValues.pdf.gamma.tras <- function(x, desp=1, alpha=4, beta=2) {
  dgamma(x-desp, shape = alpha, rate=beta)
}

# Stablish theme
comp.theme <- theme(
  #panel.grid.major = element_blank(), 
  #panel.grid.minor = element_blank(),
  #panel.background = element_blank(),
  
  # Legend position
  legend.position = c(1, 1),
  legend.justification = c("right", "top"),
  legend.box.just = "right",
  
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)

# Title
comp.title <- ggtitle("Densidad de la severidad total \n vs. \n aproximacion Gamma")

# Number of different function to be ploted
types <- c("1","2")
# Create plot
comp.p <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
# Create layers
pdf.comp.pois.layer.path <- geom_path(
  data=data.frame(type="1"),
  stat="function",
  fun = getValues.pdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  aes(colour=type, linetype=type, size=type)
)
pdf.gam.layer <- stat_function(
  data=data.frame(type="2"),
  fun = getValues.pdf.gamma.tras,
  args = list(desp=-1000/3, alpha=4/45, beta=1/15000),
  aes(colour=type, linetype=type, size=type)
)
# Colors and line types
if (colorImp) {
  aprox.color <- "purple3"
  colors <- c(pdf.comp.pois.color,aprox.color)
  sizes <- c(.5,.5)
  linetypes <-c(1,1)
} else {
  colors <- c("black", "black")
  sizes <- c(.5,.5)
  linetypes <-c(1,5)
}
# Legends
comp.an <- labs(TeX('Severidad total'), TeX('aproximacion Gamma'))

# Plot
comp.p + comp.theme + xAxis + yAxis + pdf.comp.pois.labels + comp.title + pdf.xlim + pdf.ylim + pdf.comp.pois.layer.path + pdf.gam.layer +
  scale_colour_manual(
    #name="Densidades", 
    name=NULL, 
    values=colors,
    labels = comp.an,
    breaks = types
  ) + 
  scale_linetype_manual(
    #name="Densidades", 
    name=NULL,
    values = linetypes,
    labels = comp.an,
    breaks = types
  ) +
  scale_size_manual(
    #name="Densidades", 
    name=NULL,
    values = sizes,
    labels = comp.an,
    breaks = types
  )

```
Para valores cercanos a la media es mas conveniente aproximar la distribucion Poisson Compuesta con una distribucion Normal con los siguientes parametros: 
$$\mu=E(N)E(X_1)=\frac{\lambda_{Po}}{\lambda_{exp}}=(0.1)(10000)=1000, $$
$$\sigma^2={E(x_1)}Var(N) + Var(x_1)E(N) = \frac{\lambda_{Po}}{\lambda_{exp}} + \frac{\lambda_{Po}}{\lambda_{exp}^2}=(10000)(0.1) + (10000)^2(0.1)=10001000$$
Sin embargo, esto solo funciona para valores grandes de $\lambda_{Po}$. En el siguinete grafico se muestra que la aproximacion Normal para valores alrededor de la media es bastante mala, pues como $\lambda_{Po}$ es pequena la media de la suma de variables aleatorias no corverge a la media de la aproximacion Normal:

```{r densidad vs aproximacion normal, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
# PDF Compound Poisson Distribution 
dpoiscomp <- function(x, lambda_po=4,lambda_exp=2) {
  # Dont take into account terms of the sum that are smaller than the following tolerance 
  tolerance <- 0.0000000001
  prob <- 0
  # The rest of terms
  n <- 1
  repeat {
    next_term <- exp(-lambda_po+n*log(lambda_po)-lfactorial(n)) * dgamma(x, shape=n, rate=lambda_exp)
    if (next_term < tolerance) {
      break
    }
    prob <- prob + next_term
    n <- n + 1
  }
  prob
}

# Get values to be ploted
getValues.pdf.pois.comp <- function(x, lambda_po=4, lambda_exp=2) sapply(x, FUN=dpoiscomp, lambda_po=lambda_po,lambda_exp=lambda_exp)

# PDF Gamma Trasladada
getValues.pdf.gamma.tras <- function(x, desp=1, alpha=4, beta=2) {
  dgamma(x-desp, shape = alpha, rate=beta)
}

# Create a plot
p <- ggplot()

# Stablish background and leyend position
theme <- theme(
  # Background
  #panel.grid.major = element_blank(), 
  #panel.grid.minor = element_blank(),
  #panel.background = element_blank(),
  
  # Legend position
  legend.position = c(1, 1),
  legend.justification = c("right", "top"),
  legend.box.just = "right",
  
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
# Plot axes to make it look nicer
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)

# Plot PDFs
# Labels
labels <- labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))
# Title
title <- ggtitle("Densidad de la severidad total \n vs. \n aproximacion Normal")
# Empty plot
# Number of different function to be ploted
types <- c("1","2")
# Create plot
p1 <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
# Create layers
pdf1 <- geom_path(
  data=data.frame(type="1"),
  stat="function",
  fun = getValues.pdf.pois.comp,
  args=list(lambda_po=0.1, lambda_exp=1/10000),
  aes(colour=type, linetype=type, size=type)
)
pdf2 <- stat_function(
  data=data.frame(type="2"),
  fun = dnorm,
  args = list(mean=1000, sd=sqrt((0.1)*(10000^2))),
  aes(colour=type, linetype=type, size=type)
)
# Colors and line types
if (colorImp) {
  colors <- c(pdf.comp.pois.color,aprox.color)
  sizes <- c(.5,.5)
  linetypes <-c(1,1)
} else {
  colors <- c("black", "black")
  sizes <- c(.5,.5)
  linetypes <-c(1,5)
}
# Legends
an <- labs(TeX('Severidad total'), TeX('aproximacion Normal'))

# Plot
p1 + theme + xAxis + yAxis + labels + title + pdf.xlim + pdf.ylim + pdf1 + pdf2 +
  scale_colour_manual(
    #name="Densidades", 
    name=NULL, 
    values=colors,
    labels = an,
    breaks = types
  ) + 
  scale_linetype_manual(
    #name="Densidades", 
    name=NULL,
    values = linetypes,
    labels = an,
    breaks = types
  ) +
  scale_size_manual(
    #name="Densidades", 
    name=NULL,
    values = sizes,
    labels = an,
    breaks = types
  )
```

En este caso, la media de la distribucion de la frecuencia de los siniestros en un ano es un valor muy pequeno dado por $\lambda_{Po}=`r lambda_po`$, entonces lo mas recomendable para estimar percentiles alrededor de la media es aproximar la funcion de distribucion mediante una distribucion lognormal:

```{r densidad vs aproximacion lognormal, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
get.dlnorm <- function(x, corr=0, meanlog=0, sdlog=1) {
  dlnorm(x-corr, meanlog = meanlog, sdlog = sdlog)
}

# Plot PDFs
# Labels
labels.comp <- labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))
# Title
title.comp <- ggtitle("Densidad de la severidad total \n vs. \n aproximacion Lognormal")
# Empty plot
# Number of different function to be ploted
types <- c("1","2")
# Create plot
p1 <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
# Create layers
pdf1.pois.comp <- geom_path(
  data=data.frame(type="1"),
  stat="function",
  fun = getValues.pdf.pois.comp,
  args=list(lambda_po=0.1, lambda_exp=1/10000),
  aes(colour=type, linetype=type, size=type)
)
pdf2.log.norm <- stat_function(
  data=data.frame(type="2"),
  fun = get.dlnorm,
  args = list(corr=-5000,meanlog = 4, sdlog = 5),
  aes(colour=type, linetype=type, size=type)
)
# Legends
an <- labs(TeX('Severidad total'), TeX('aproximacion Lognormal'))
# Plot
p1 + theme + xAxis + yAxis + labels.comp + title.comp + 
  xlim(0,80000) + 
  ylim(0,.00001) + 
  pdf1.pois.comp + pdf2.log.norm +
  scale_colour_manual(
    #name="Densidades", 
    name=NULL, 
    values=colors,
    labels = an,
    breaks = types
  ) + 
  scale_linetype_manual(
    #name="Densidades", 
    name=NULL,
    values = linetypes,
    labels = an,
    breaks = types
  ) +
  scale_size_manual(
    #name="Densidades", 
    name=NULL,
    values = sizes,
    labels = an,
    breaks = types
  )
```

Esta proximacion Lognormal tiene un corrimiento igual $5000$, una media de $4$ y una desviacion estandar de $5$. Si bien esta aproximacion Lognormal es buena, no hay teoria que la justifique.


\subsection{1.5 distribucion empirica}

La distribucion empirica de la severidad total esta dada por

```{r distribucion empirica de la severidad total, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
df <- data.frame(severities)
theme <- theme(
  # Center plot title
  plot.title = element_text(hjust = 0.5)
)
if (colorImp) emp.color <- "#add8e6" else emp.color <- "black"
ggplot() + stat_ecdf(data=df, aes(x=severities), geom = "step", color=emp.color) +
  labs(x = TeX('$s$'), y = TeX('$F_{S_n}(s)$')) + asinth.axis + xAxis + yAxis +
  ggtitle("distribucion empirica de la severidad total") + theme + cdf.ylim
```

Entonces un intervalo de confianza a un nivel de $(1-\alpha)100\%$ para distribucion de la serveridad total $F_{S}(s)$ esta dado por
$$\left(F_{s_n}(s)-\sqrt\frac{\ln\frac{2}{\alpha}}{2n}, F_{s_n}(s)+\sqrt\frac{\ln\frac{2}{\alpha}}{2n}\right)$$
Si se construyen los intervalos de confianza al $95\%$ para $F_S(s)$ utilizando la distribucion empirica se tiene lo siguiente:
```{r, echo=FALSE, warning=FALSE}
Fn <- c(1:10000)
ordenados <- sort(severities)
alfa <- 0.05
limsup <- c(1:10000)
liminf <- c(1:10000)
for (i in 1:10000) {
  cuenta<-0
  for (j in 1:10000) {
    if (ordenados[j]<=ordenados[i]){
      cuenta=cuenta+1
    }
  }
  Fn[i] <- cuenta/10000
  limsup[i] <- Fn[i] + sqrt(log(2/alfa)/(2*10000))
  if (limsup[i] > 1) limsup[i] <- 1
  liminf[i] <- Fn[i] - sqrt(log(2/alfa)/(2*10000))
}
```

```{r, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
types <- c("1","2","3","4")
p <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
theme <- theme(
  # Leyend position
  legend.position = c(1, 0),
  legend.justification = c("right", "bottom"),
  legend.box.just = "right",
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)
labels <- labs(x = TeX('$s$'), y = TeX('$F_{S_n}(s)$'))
title <- ggtitle("Intervalos de confianza al 95% para \n la distribucion de la severidad total")

fun2 <- geom_step(data=data.frame(ordenados,limsup, type="1"), aes(x=ordenados, y=limsup, colour=type, linetype=type, size=type)) 
fun1 <- geom_step(data=data.frame(ordenados,Fn, type="3"), aes(x=ordenados, y=Fn, colour=type, linetype=type, size=type)) 
fun3 <- geom_step(data=data.frame(ordenados,liminf, type="4"), aes(x=ordenados, y=liminf, colour=type, linetype=type, size=type)) 
cdf.layer <- geom_path(
  data=data.frame(type="2"),
  stat="function",
  fun=getValues.cdf.comp.pois,
  args=list(lambda_po=lambda_po, lambda_exp=lambda_exp),
  aes(colour=type, linetype=type, size=type)
)
an <- labs(TeX('Cota superior'), TeX('teorica'),TeX('empirica'), TeX('Cota inferior'))

if (colorImp) {
  colors <- c("#800080","#ffa500","#add8e6","purple")
  sizes <- c(.4,2,1,.4)
  linetypes <- c(1,1,1,1)
} else {
  colors <- c("black","black","black","black")
  sizes <- c(1,1,1,1)
  linetypes <-c(1,2,3,4)
}

p+theme+xAxis+yAxis+labels+title+cdf.layer+fun1+fun2+fun3+cdf.xlim+cdf.ylim+ asinth.axis +
scale_colour_manual(
  #name="Name",
  name = NULL,
  values = colors,
  labels = an,
  breaks = types
) +
scale_linetype_manual(
  #name="Name",
  name = NULL,
  values = linetypes,
  labels = an,
  breaks = types
) +
scale_size_manual(
  #name="Name",
  name = NULL,
  values = sizes,
  labels = an,
  breaks = types
)

```


\section{Estimacion de la frecuencia y severidad}

\subsection{2.1 simulacion de los pares $\left(T_i,x_i\right)$}

Como la frecuencia de los eventos en un ano se distribuye Poisson con media $\lambda_{Po}=`r lambda_po`$, entonces las diferencias de tiempo entre las ocurrencias de los eventos siguen una distribucion exponencial con media $1/\lambda=\lambda_{Po}=`r lambda_po`$, es decir, los tiempo inter-arribos siguen una distribucion exponencial con media $1/\lambda=\lambda_{Po}=`r lambda_po`$. Simulando los tiempo inter-arribos exponenciales se puden simular las fechas de ocurrencias de los siniestros a partir de hoy. A continuacion se muestran las primeras $10$ realizaciones de las fechas de los siniestros y los montos correspondientes distribuidos exponencialmente con media $1/\lambda_{exp}=`r denom`$:

```{r simulated pairs, echo=FALSE, warning=FALSE, message=FALSE}

rate   <- lambda_po
start  <- 2018
# Tiempo interarribos
per <- rexp(10000, rate=rate)
# Obtener las fechas de los cinistros
per[1] <- per[1]+start
# Fechas de los siniestros
PerTot <- cumsum(per)
# Montos de los siniestros
montos <- rexp(10000 ,rate=lambda_exp)

convert.seconds <- function(x) {
  a <- x-2018
  b <- a*31556952
  c <- as.POSIXct(b, origin = "2018-01-01", tz = "UTC")
  as.character(c)
}
dates <- sapply(PerTot, convert.seconds)


pairs.df <- data.frame(dates, montos)
names(pairs.df) <- c("Fechas", "Montos")
kable(head(pairs.df, 10))
```

\pagebreak

\subsection{2.2 Serie de tiempo} 

A continuacion se muestra la serie de tiempo generada

```{r, serie de tiempo, echo=FALSE, fig.height = 12, fig.width = 10}
# Ploting time series
# https://www.neonscience.org/dc-time-series-plot-ggplot-r
fechonsias <- pairs.df[[1]]
funciononsia <- function(x) {
  value <- NA
  if (match(x,fechonsias) %% 500 !=0) {
    value <- NA
  } else {
    fechaSeparada <- strsplit(as.character(x), " ")
    value <- fechaSeparada[[1]][1]
  }
  value
}
fechunias <- sapply(fechonsias, funciononsia)
montunios <- pairs.df[[2]]
dfonsio <- data.frame(fechunias, montunios)
names(dfonsio) <- c("fechonson", "montonson")

ggplot(data = dfonsio, aes(x = c(1:10000), y = montonson, group = 1)) + 
  geom_bar(stat="identity", color = "#00AFBB", size = .1, alpha=.1, na.rm = TRUE) +
  geom_point(size=.005, color="blue", alpha=0.5) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size=5)) + 
  scale_x_discrete(limits=dfonsio[[1]], na.translate = FALSE) + xlab("Fecha") + ylab("Monto") + 
  geom_hline(yintercept=10000, size=1, color="cyan") + coord_flip() + scale_y_reverse()
```

La linea azul claro indica la media de la distribucion teorica de los montos a partir de la cual fueron simulados los datos. No se observa dependencia ni efectos estacionales.

\subsection{2.3 Distribución empirica de la severidad}

Con los valores simulados de los montos, se puede construir la funcion de distribucion de probabilidad empirica de la severidad:

```{r calculo empirica severidad, echo=FALSE, warning=FALSE}
Fn.sev <- c(1:10000)
empirica<-ecdf(montos)
ordenados.sev <- sort(montos)
alfa.sev <- 0.05
limsup.sev <- c(1:10000)
liminf.sev <- c(1:10000)
for (i in 1:10000) {
  cuenta<-0
  for (j in 1:10000) {
    if (ordenados.sev[j]<=ordenados.sev[i]){
      cuenta=cuenta+1
    }
  }
  Fn.sev[i] <- cuenta/10000
  limsup.sev[i] <- Fn.sev[i] + sqrt(log(2/alfa.sev)/(2*10000))
  if (limsup.sev[i] > 1) limsup.sev[i] <- 1
  liminf.sev[i] <- Fn.sev[i] - sqrt(log(2/alfa)/(2*10000))
}
```

```{r, distribucion empirica de la severidad, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
types <- c("1","2","3","4")
p <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
theme <- theme(
  # Leyend position
  legend.position = c(1, 0),
  legend.justification = c("right", "bottom"),
  legend.box.just = "right",
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)
labels <- labs(x = TeX('$m$ (montos)'), y = TeX('$F_{M_n}(m)$'))
title <- ggtitle("Intervalos de confianza al 95% para \n la distribucion de la severidad")

ordenados.sev <- sort(montos)
fun2 <- geom_step(data=data.frame(ordenados.sev,limsup, type="1"), aes(x=ordenados.sev, y=limsup.sev, colour=type, linetype=type, size=type)) 
fun1 <- geom_step(data=data.frame(ordenados.sev,Fn, type="3"), aes(x=ordenados.sev, y=Fn.sev, colour=type, linetype=type, size=type)) 
fun3 <- geom_step(data=data.frame(ordenados.sev,liminf, type="4"), aes(x=ordenados.sev, y=liminf.sev, colour=type, linetype=type, size=type)) 
cdf.layer <- geom_path(
  data=data.frame(type="2"),
  stat="function",
  fun=pexp,
  args=list(rate=lambda_exp),
  aes(colour=type, linetype=type, size=type)
)
an <- labs(TeX('Cota superior'), TeX('teorica'),TeX('empirica'), TeX('Cota inferior'))

if (colorImp) {
  colors <- c("#800080","#ffa500","#add8e6","purple")
  sizes <- c(.4,2,1,.4)
  linetypes <- c(1,1,1,1)
} else {
  colors <- c("black","black","black","black")
  sizes <- c(1,1,1,1)
  linetypes <-c(1,2,3,4)
}

p+theme+xAxis+yAxis+labels+title+cdf.layer+fun1+fun2+fun3+cdf.xlim+ylim(0,1)+ asinth.axis +
scale_colour_manual(
  #name="Name",
  name = NULL,
  values = colors,
  labels = an,
  breaks = types
) +
scale_linetype_manual(
  #name="Name",
  name = NULL,
  values = linetypes,
  labels = an,
  breaks = types
) +
scale_size_manual(
  #name="Name",
  name = NULL,
  values = sizes,
  labels = an,
  breaks = types
)
```

Dado el numero de observaciones (simulaciones) $n=10000$, se tiene que la funcion de distribucion empirica de la severidad se aproxima bastante bien a la funcion de distribucion teorica y la longitud de los intervalos de confianza no es muy grande. Note que las cotas superiores e inferiores "abrazan estrechamente" a la funcion de distribucion teorica. 

\subsection{2.4 Histograma de la severidad}

Agrupando los montos de los siniestros en intervalos de longitud $5000$, se obtiene el siguinete histograma:
```{r histograma severidad, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
if (colorImp) {
  hist.color <- "darkturquoise"
  hist.fill <- "cyan"
  hist.alpha <- "0.4"
} else {
  hist.color <- "black"
  hist.fill <- "white"
  hist.alpha <- "1"
}

montos.df <- data.frame(montos)
breaks <- seq(1, 80000, by=5000)
hist.p <- ggplot(data=montos.df, aes(x=montos)) +
  geom_histogram(breaks=breaks, color=hist.color, fill=hist.fill, alpha=hist.alpha) + 
  labs(x = TeX('Severidad$'), y = TeX('Frecuencia')) +
  ggtitle("Histograma de la severidad") + title.theme
hist.p
```

Con un escalamiento adecuado sobre las frecuencias (note el cambio en la escala en el eje $y$) se puede observar la enorme similitud entre la densidad teorica y el histograma:

```{r  histograma con densidad sev, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}

pdf.sev.layer <- stat_function(
  aes(x=c(0,10)),
  fun=dexp,
  args=list(rate=lambda_exp),
  color="blue"
)

hist.p2.sev <- ggplot() + xAxis + yAxis + title.theme + pdf.xlim + ylim(0,.0001) + geom_histogram(data=montos.df, aes(x=montos, y=.00000002*..count..), breaks=breaks, color=hist.color, fill=hist.fill, alpha=hist.alpha) + pdf.sev.layer +
  ggtitle("funcion de densidad de probabilidad \n de la severidad total") +
  labs(x = TeX('$s$'), y = TeX('$f_S(s)$'))
hist.p2.sev
```

\subsection{2.5 Caracteristicas de la distribucion empirica}

Sea $M$ la variable aleatoria que indica el monto de un siniestro, entonces el valor esperado de $M$ limitado a $l$ esta dada por

$$  E\left( \min{M, l} \right)=\int_{0}^{l}S_{x_1}(t) \, \mathrm{d}t=\int_{0}^{l} e^{-\lambda_{exp}t} \, \mathrm{d}t = \frac{1-e^{-\lambda_{exp}l}}{\lambda_{exp}} $$

A continuacion se presenta a la media limitada de los montos como funcion del limite:

```{r Media limitada, echo=FALSE, warning=FALSE, message=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
severities2 <- sort(unique(montos))
##Media limitada:
n=10000
media_limitada<-NULL
for(i in 1:length(severities2)){
  u<-severities2[i]
  media_limitada[i]<-(sum(montos>u)*u + sum(montos[montos<=u]))/n
}
```

```{r media limitada 2, echo=FALSE, warning=FALSE, message=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
funcionsia <- function(x) (1-exp(-lambda_exp*x))/(lambda_exp)

types <- c("1","2")
p.m <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
theme <- theme(
  # Leyend position
  legend.position = c(1, 0),
  legend.justification = c("right", "bottom"),
  legend.box.just = "right",
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)
labels <- labs(x = TeX('$s$'), y = TeX('$F_{S_n}(s)$'))
title <- ggtitle("Funcion media limiatada")

points <- geom_point(
  data=data.frame(severities2, media_limitada, type="1"),
  aes(x=severities2, y=media_limitada, colour=type, linetype=type, size=type),
  shape=0
)

curve <- geom_path(
  data=data.frame(type="2"),
  stat="function",
  fun=funcionsia,
  aes(colour=type, linetype=type, size=type)
)

an <- labs(TeX('Valores simulados'), TeX('Media limitada'))

if (colorImp) {
  colors <- c("purple","cyan")
  sizes <- c(.3,1)
  linetypes <- c(1,1)
} else {
  colors <- c("black","black")
  sizes <- c(1,1)
  linetypes <-c(1,2)
}

p.m+theme+xAxis+yAxis+labs(x="Limite", y="Media limitada")+title+curve+points+xlim(0,80000)+ylim(0,10000)+ asinth.axis +
scale_colour_manual(
  #name="Name",
  name = NULL,
  values = colors,
  labels = an,
  breaks = types
) +
scale_linetype_manual(
  #name="Name",
  name = NULL,
  values = linetypes,
  labels = an,
  breaks = types
) +
scale_size_manual(
  #name="Name",
  name = NULL,
  values = sizes,
  labels = an,
  breaks = types
)
```

Como los montos son distribuidos exponencialmente con media $E(x_1)=1/\lambda_{exp}$, 

Media en exceso:

```{r media en exceso, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
##Media en exceso
media_exceso<-NULL
for(i in 1:length(severities2)){
  d<-severities2[i]
  media_exceso[i]<- sum(montos[montos>d]-d)/sum(montos>d)
}
#plot(severities2, media_exceso, main="Media en exceso", xlab="x", ylab="Media en exceso")
ggplot() +
  geom_point(data=data.frame(severities2, media_exceso), aes(x=severities2, y=media_exceso), shape=1, color="black") +
labs(x="Montos",y="Media en exceso") + title.theme +
  ggtitle("Media exceso")



funcionsia <- function(x) (1-exp(-lambda_exp*x))/(lambda_exp)

types <- c("1","2")
p.m <- ggplot(data.frame(type=types), aes(colour=type, linetype=type, size=type))
theme <- theme(
  # Leyend position
  legend.position = c(1, 0),
  legend.justification = c("right", "bottom"),
  legend.box.just = "right",
  # Legend boxes
  legend.key = element_rect(colour = 'black', fill = 'transparent', size = .5, linetype=0),
  legend.key.width = unit(1.5, "lines"),
  legend.background = element_rect(fill="transparent"),
  # Center plot title
  plot.title = element_text(hjust = 0.5),
  legend.text=element_text(size=8)
)
xAxis <- geom_hline(yintercept = 0, size = .1)
yAxis <-geom_vline(xintercept = 0, size = .1)
labels <- labs(x = TeX('$s$'), y = TeX('$F_{S_n}(s)$'))
title <- ggtitle("Funcion media limiatada")

points <- geom_point(
  data=data.frame(severities2, media_limitada, type="1"),
  aes(x=severities2, y=media_limitada, colour=type, linetype=type, size=type),
  shape=0
)

curve <- geom_path(
  data=data.frame(type="2"),
  stat="function",
  fun=funcionsia,
  aes(colour=type, linetype=type, size=type)
)

an <- labs(TeX('Valores simulados'), TeX('Media limitada'))

if (colorImp) {
  colors <- c("purple","cyan")
  sizes <- c(.3,1)
  linetypes <- c(1,1)
} else {
  colors <- c("black","black")
  sizes <- c(1,1)
  linetypes <-c(1,2)
}

p.m+theme+xAxis+yAxis+labs(x="Limite", y="Media limitada")+title+curve+points+xlim(0,80000)+ylim(0,10000)+ asinth.axis +
scale_colour_manual(
  #name="Name",
  name = NULL,
  values = colors,
  labels = an,
  breaks = types
) +
scale_linetype_manual(
  #name="Name",
  name = NULL,
  values = linetypes,
  labels = an,
  breaks = types
) +
scale_size_manual(
  #name="Name",
  name = NULL,
  values = sizes,
  labels = an,
  breaks = types
)




```

Motalidad empirica:

```{r mortalidad empirica, echo=FALSE, warning=FALSE, fig.width=4.5, fig.height=3, fig.align = "center"}
#Mortalidad empirica
fn<-NULL
mort_emp<-NULL
for(i in 1:length(severities2)){
  fn[i]<- empirica(severities2[i+1])-empirica(severities2[i])
  mort_emp[i]<-fn[i]/(1-empirica(severities2[i]))
  }
#plot(severities2,mort_emp, main="Mortalidad empirica", xlab="x", ylab="Mortalidad empirica", color="#cf78b7")
ggplot() +
  geom_point(data=data.frame(severities2, mort_emp), aes(x=severities2, y=mort_emp), shape=2, color="#cf78b7") +
labs(x="Montos",y="Mortalidad empirica") + title.theme +
  ggtitle("Mortalidad empirica")
```

2.6 

```{r Prueba Chi-Square, echo=FALSE, warning=FALSE}
##Datos agrupados
nj<-NULL
agrupados1<-data.frame(cj_1=seq(0,max(severities2),5000), cj=seq(5000,max(severities2)+5000,5000))
                      
for(i in 1:length(agrupados1$cj_1)){
  nj[i]<-sum(montos<agrupados1$cj[i] & agrupados1$cj_1[i] <= montos)
}
agrupados1[3]<-nj
row.names(agrupados1)<-c(1:length(agrupados1$V3))

 agrupados<-agrupados1
k=1
while(agrupados$V3[k]>=5){
  aux <- k
k=k+1
}

  aux2<-0
  for(i in 1:(length(agrupados$V3)-aux)){
    aux2<-aux2+agrupados$V3[aux+i]
  }
agrupados$V3[aux+1]<-aux2

for(i in 1:(length(agrupados$cj)-aux-1)){
   agrupados$V3[aux+1+i]<-0
}

agrupados$cj[aux+1]<- agrupados$cj[length(agrupados$cj_1)]
 agrupados<-subset(agrupados, agrupados$V3>0) 
 agrupados<-rbind(agrupados,1)
 agrupados$cj_1[length(agrupados$V3)]<-agrupados$cj[length(agrupados$V3)-1]
 agrupados$cj[length(agrupados$cj)]<-"inf"
 agrupados$V3[length(agrupados$V3)]<-0

 ##Estimo el parámetro para una exponencial por MV
theta<-1/mean(montos)
E<-NULL
E[1]<-10000*(pexp(5000,theta))
for(i in 2:(length(agrupados$cj_1)-1)){
  E[i]<-10000*(pexp(as.numeric(agrupados$cj[i]),theta)-pexp(as.numeric(agrupados$cj_1[i]),theta))
}
E[length(agrupados$cj_1)]=10000*(1-pexp(as.numeric(agrupados$cj_1[length(agrupados$cj_1)]),theta))
agrupados[4]<-E

Q<-NULL
for(i in 1:(length(agrupados$cj_1))) {
  Q[i]<-((as.numeric(agrupados$V3[i])-as.numeric(agrupados$V4[i]))^2)/as.numeric(agrupados$V3[i])
}
Q[length(agrupados$cj_1)]=0
agrupados[5]<-Q
sumaQ<-sum(Q)
gl<-length(agrupados$cj_1)-3
test<-qchisq(.95,gl)

sumaQ<test
##No rechazamos H0. Los datos provienen de una distribuci´ón exponencial.
```

Realizando la prueba Ji-Cuadrada, se tiene que el la estadistica de prueba toma el siguite valor
$$Q=`r sumaQ`$$
Por lo tanto la hipotesis de que la severidad sigue una distribucion exponencial con media $10000$ no es rechazada.

2.7 

2.7 Mediante el q-q plot, indica si el modelo ajustado sobreestima o subestima las probabilidades de eventos de monto alto. 

```{r echo=FALSE, warning=FALSE, message=FALSE}
##barplot(E)
#Monto
u2 <- runif(10000,0,1)
xi<-(-10000)*log(1-u2)
hist(xi,probability = TRUE,xlim = c(0,100000),breaks = 100,main = "Exponencial generada (10,000)")


#Q-Q Plot
Fn2 <- c(1:10000)
for (i in 1:10000){
  Fn2[i] <- (-10000)*log(1-(i/10001))
}

qqplot(sort(xi),Fn2, plot.it = TRUE)

```



2.8 Suponiendo que la frecuencia anual se distribuye Poisson, estima su parámetro y construye un intervalo de confianza para la siniestralidad promedio.
```{r}

```


\section{Estimacion con sensura y truncamiento}

\subsection{3.1}

Los montos de los siniestros son los siguientes:

```{r montos simulados, echo=FALSE, warning=FALSE}

```

3.1 Sobre los 10000 siniestros simulados en la pregunta anterior, considera ahora que aplicarán un deducible de $5,000 y un límite de $30,000. Construye ahora el archivo de indemnizaciones correspondiente. ¿Qué proporción de los datos originales tienes ahora? ¿Pudiste haber estimado esta proporción de manera analítica con la distribución exponencial?
```{r}
##TRUNCAMIENTO
Indem<-montos
for ( i in 1:10000){
  
  if(Indem[i]<=5000){
    Indem[i]=0
  }
}
  for(i in 1:10000){
      if(Indem[i]>=30000){
        Indem[i]=25000
      }
  }
Indemnizacion<-as.data.frame(Indem)
head(Indemnizacion)

Indem1<-subset(Indem,Indem !=0)

##El n´úmero de indemnizaciones que quedan despu´és del truncamiento y el l´ímite
length(Indem1)
```
